#ifndef __COLLECTIVE_VARIABLE_H__
#define __COLLECTIVE_VARIABLE_H__

/*! \file CollectiveVariable.h
    \brief Declares the CollectiveVariable abstract class
 */

#include <hoomd/ForceCompute.h>

#include <hoomd/extern/pybind/include/pybind11/pybind11.h>

#include <string.h>

/*! Abstract interface for a collective variable

    All C++ implementations of collective variables inherit from this class.
    A CollectiveVariable is an extension of a ForceCompute,
    and can compute forces.

    The force generated by a collective variable (i.e. its negative derivative
    with respect to particle positions) must be multiplied
    by a bias factor (the partial derivative of the biasing potential with
    respect to the collective variable). The bias factor is set using
    the method setBiasFactor().

    Collective variables should have a potential energy of zero,
    since they are not directly added to the Hamiltonian (only via the
    biasing potential). Instead, the value of the collective variable
    can be queried using getCurrentValue().

 */
class CollectiveVariable : public ForceCompute
    {
    public:
        enum umbrella_Enum
            {
            no_umbrella = 0,        //!< no umbrella potential
            linear,                 //!< energy linear in the collective variable
            harmonic,               //!< a harmonic umbrella potential
            wall,                   //!< soft wall umbrella potential
            gaussian                //!< Gaussian umbrella potential
            };

 
        /*! Constructs a collective variable
            \param sysdef The system definition
            \param name The name of this collective variable
         */
        CollectiveVariable(std::shared_ptr<SystemDefinition> sysdef, const std::string& name);
        virtual ~CollectiveVariable() {}

        /*! Returns the current value of the collective variable
         *  \param timestep The currnt value of the timestep
         */
        virtual Scalar getCurrentValue(unsigned int timestep) { return Scalar(0.0); }

        /*! Set the current value of the bias factor.
            This routine has to be called before force evaluation
            by the integrator.

            \param bias The value that multiplies the force
         */
        virtual void setBiasFactor(Scalar bias)
            {
            m_bias = bias;
            }

        /*! Evaluate a harmonic potential function of the collective variable
         * \param harmonic True if harmonic potential should be active
         */
        void setUmbrella(umbrella_Enum umbrella)
            {
            m_umbrella = umbrella;
            if (umbrella==no_umbrella)
                m_bias=Scalar(0.0);
            }

        /*! Set spring constant for harmonic potential
         * \param kappa Spring constant (in units of the collective variable)
         */
        void setKappa(Scalar kappa)
            {
            m_kappa = kappa;
            }

        /*! Set width of flat region of umbrella potential
         * \param width Width of flat region (in units of collective variable)
         */
        void setWidthFlat(Scalar width)
            {
            m_width_flat= width;
            }

        /*! Set prefactor of umbrella potential
         *! \param scale Multiplicative scale factor
         */
        void setScale(Scalar scale)
            {
            m_scale = scale;
            }

        /*! Set minimum position of harmonic potential
         * \param cv0 Minimum position (units of c.v.)
         */
        void setMinimum(Scalar cv0)
            {
            m_cv0 = cv0;
            }

        /*! Returns the name of the collective variable
         */
        std::string getName()
            {
            return m_cv_name;
            }

        /*! Computes the derivative of the collective variable w.r.t. the particle coordinates
         * and stores them in the force array.
         */
        void computeDerivatives(unsigned int timestep)
            {
            m_bias = Scalar(1.0);

            computeBiasForces(timestep);
            }

        /*! Returns true if the collective variable can compute derivatives
         *  w.r.t. particle coordinates
         */
        virtual bool canComputeDerivatives()
            {
            return true;
            }

        /*! Returns the value of the harmonic umbrella potential
         * \param timestep
         */
        Scalar getUmbrellaPotential(unsigned int timestep);

        /*! Returns true if the evaluation of this variable depends on the evaluation
         * of the other variables
         */
        virtual bool requiresNetForce()
            {
            return false;
            }

        /*! Returns the names of provided log quantities.
         */
        virtual std::vector<std::string> getProvidedLogQuantities()
            {
            std::vector<std::string> list = ForceCompute::getProvidedLogQuantities();
            list.push_back("umbrella_energy");
            return list;
            }

        /*! Returns the value of a specific log quantity.
         * \param quantity The name of the quantity to return the value of
         * \param timestep The current value of the time step
         */
        Scalar getLogValue(const std::string& quantity, unsigned int timestep)
            {
            if (quantity == "umbrella_energy_"+m_cv_name)
                {
                return getUmbrellaPotential(timestep);
                }

            // nothing found?
            m_exec_conf->msg->error() << "cv.*: Invalid log quantity " << quantity << std::endl;
            throw std::runtime_error("Error querying log quantity");
            }

    protected:
        /*! \param timestep The current value of the time step
         */
        void computeForces(unsigned int timestep);

        /*! Compute the biased forces for this collective variable.
            The force that is written to the force arrays must be
            multiplied by the bias factor.

            \param timestep The current value of the time step
         */
        virtual void computeBiasForces(unsigned int timestep) { };

        Scalar m_bias;         //!< The bias factor multiplying the force

        std::string m_cv_name; //!< Name of the collective variable

    private:
        umbrella_Enum m_umbrella;  //!< Type of umbrella potential to evalaute
        Scalar m_cv0;              //!< Minimum position of umbrella tential
        Scalar m_kappa;            //!< Stiffness of umbrella potential
        Scalar m_width_flat;       //!< Region where the umbrella potential is flat
        Scalar m_scale;           //!< Prefactor of umbrella potential
    };

//! Export the CollectiveVariable class to python
void export_CollectiveVariable(pybind11::module& m);

#endif // __COLLECTIVE_VARIABLE_H__
